---
title: 'Practical 5: Unconstrained Ordination'
author: "Bio2020"
output: html_document
---
## Aim

The main aims of this practical are to learn more on the use and interpretation of three types of unconstrained ordination: 

 - Principal components analysis (PCA)
 - Correspondence analysis (CA)
 - Non-metric multidimensional scaling (NMDS).

## Setting up for the practical  

First, go to Canvas and download the **dune.csv** data set and save it to your Bio2020 directory data folder.  

Now navigate to your Bio2020 folder and open up your existing project for this module in your directory and load it into R as you have done in previous practicals. Create a new R script and save it to your current working directory (the location of your Bio2020 project) as Practical_5. 

#### Installing and Loading Packages  

Install the package **vegan** as you have done in previous sessions by running

```{r eval = FALSE}
install.packages("vegan")
```

Load the **bio2020** and **vegan** packages as you have done in previous sessions.    
```{r echo=TRUE, message=FALSE, warning=FALSE}
library(bio2020)
library(vegan)
```

#### Loading Data  

Now load in the .csv file you downloaded at the very beginning of the practical. If the data is not in a folder called data, you will have to change the file path to match where your data is stored. 
```{r echo=TRUE,  message=FALSE, warning=FALSE}
dune <- read.csv("Data/dune.csv", row.names=1)
```

Vegan has some inbuilt data files, let's load "varespec" and "varechem".
```{r echo=TRUE,  message=FALSE, warning=FALSE}
data(varespec)
data(varechem)
```

## Introduction  

Ordination is a way of arranging sites along gradients in such a way that we can try and explain patterns of variation within the noise. Linear methods (**PCA**) assume the observations respond roughly linearly along these gradients. Unimodal methods (**CA**) assume the observations will respond non-linearly. Distance-based models (**NMDS**) use the relative rankings of your sites along each axis.

Unconstrained ordination is a useful tool for determining whether there is a relationship between multiple **response variables**. Through measuring the similarity in their **composition**, it is easier to compare samples. When the composition of samples is summarised on a continuous scale it is referred to as an **ordination**, whereas on a categorical scale it is known as **classification** or **clustering**.

### Summary Statistics 

It is always good to start by observing the data and running some summary statistics. 
```{r echo=TRUE, include=TRUE, results = 'hide'}
summary(varespec)

summary(dune)
```

However, you will notice that this output is rather large, hence why it is not included here. With big datasets it can be easier to observe the data by simply using **head()** to get a snapshot of the data, and then **nrow()**, **ncol()**, **rownames()**, and **colnames()** to explore the data a bit more. Similarly, **str()** can be used here to examine the structure of the data, but again this is a large output with these datasets.

```{r echo = TRUE, include = TRUE}
head(varespec)
nrow(varespec)
ncol(varespec)
rownames(varespec)
colnames(varespec)


head(dune)
nrow(dune)
ncol(dune)
rownames(dune)
colnames(dune)
```

## Principal Components Analysis

For the purpose of clarity the wrapper function **ordi_pca()** in the package **bio2020** will be used in this practical. A typical PCA in R has this format: **ordi_pca(data)**

In the tutorial you saw how the arch or horseshoe effect can be a problem with ecological or gene sequencing data. Although **unimodal methods** are a good alternative, you can implement transformations using the **decostand()** function. Here, we use **scale = TRUE** to give the data **unit variance**, and the **hellinger** transformation, which works well with environmental and species data.
```{r}
varespec_pca <- ordi_pca(decostand(varespec, method = "hellinger"), scale = TRUE)
varespec_pca

```

Output explained:

- **Call** - This is a reminder of how you fitted the PCA.
- **Inertia** - Total inertia is a measure of total variance.
- **Unconstrained** - How many correlations have been explained by the ordination axes. In this case, there is one less than the number of variables.
- **Eigenvalues** - Measure of the amount of variance that is explained by each of the axes
- **PC1** - The first axes, and will explain the largest amount of variation of all the axes.

To see all 23 axes, use **summary()**. This is a large output so it is not included here.
```{r echo=TRUE, include=TRUE, results = 'hide'}
summary(varespec_pca)
```

Output explained:

- The top 6 lines are the same as the PCA output
- **Eigenvalues** are the amount of inertia (variance) explained by each axis. If added up for all 23 axes, it will be the same as the total inertia.
- **Proportion explained** is the amount of total variance explained, and if added up for all 23 axes will equal 1.00.
- **Cumulative proportion** is the cumulative total of the proportion of each axes. While **PC1** explains 0.5384 and **PC2** explains 0.2543 of the variance, their *cumulative* proportion is 0.7927 because it is the total amount of variance they explain together.
- **Species and Site scores** - the relative weight each species and/or site has within each axes.

Whereas before transforming, as in the tutorial, the first two axes explained ~80% of the variation, here they account for a lot less. 

### Visualising your PCA results

In theory, you could plot all the axes on one plot and compare them. However, the more axes you have, the more dimensions you will need to visualise them in. The human brain cannot easily visualise multiple dimensions, so we would have to plot them in 2D. Therefore, if you want to include more axes the amount of plots required to compare them increases quickly. For example, if we wanted to look at PC1, PC2, *and* PC3, we would need the following plots: PC1/PC2, PC1/PC3, PC2/PC1, PC2/PC3, PC3/PC1, and PC3/PC2. Generally, the first two axes tend to explain the majority of the variation, so these are usually plotted.

```{r}
# both sites and species
ordi_plot(varespec_pca, geom = "text")

# just sites
ordi_plot(varespec_pca, layers="sites", geom="text") %>% 
  gf_labs(title="PC1 and PC2 of varespec data showing sites") %>% 
  gf_lims(x = c(-2.5, 5), y=c(-3, 4))

#just species
ordi_plot(varespec_pca, layers="species", geom="text") %>% 
  gf_labs(title="PC1 and PC2 of varespec data showing species codes") %>% 
  gf_lims(x = c(-0.7, 0.8), y=c(-0.45, 0.7))

biplot(varespec_pca, scaling = "symmetric")

```

Although the first two axes explain a lot less variation when transformed (19.55% and 11.67%, respectively), the arch effect has been removed.

Species that are close together tend to co-occur at particular sites, and sites that are close together have similar species composition. Species that are close to the zero-zero lines are more common across all sites. You will notice that due to clustering it is difficult to make some species/sites, so you can use **ordi_identify()** to pick out the interesting ones.

```{r echo=TRUE, include=TRUE, results = 'hide'}
varespec_plt <- ordi_plot(varespec_pca, layers="species", geom="text")
varespec_plt
ordi_identify(varespec_plt)
```

### Relate PCA to explanatory variables

```{r}

# Extract the PC1 site scores
varespec_pc1 <- scores(varespec_pca, display="sites", choices = 1)

# Create plot (point plot because it is continuous data)
gf_point(varespec_pc1 ~ pH, data=varechem) 
```

Think about how the PC1 scores relate to the environment, and try the same with PC2.

## Correspondence Analysis

The wrapper function **ordi_ca()** in the package **bio2020** will be used in this practical. A typical PCA in R has this format: **ordi_ca(data)**

Correspondence analysis is a weighted form of PCA that can fit non-linear responses. The weighting means the analysis is on the relative composition instead of absolute values. It is similar to PCA in that species that are close together tend to co-occur, and sites that are close together tend to have similar species composition.

```{r}
ca <- ordi_ca(dune)
ca
```

Output explained (similar to PCA):

- **Call** - This is a reminder of how you fitted the CA.
- **Inertia** - Total inertia is a measure of total variance.
- **Unconstrained** - How many correlations have been explained by the ordination axes. In this case, there is one less than the number of variables.
- **Eigenvalues** - Measure of the amount of variance that is explained by each of the axes

To see the full output, use **summary()**. Again, this is a large output so it is not shown here.
```{r echo=TRUE, include=TRUE, results = 'hide'}
summary(ca)
```

Output explained (similar to PCA):

- **CA1** - The first axes, and will explain the largest amount of variation of all the axes.
- The top 6 lines are the same as the CA output
- **Eigenvalues** are the amount of inertia (variance) explained by each axis. If added up for all 23 axes, it will be the same as the total inertia.
- **Proportion explained** is the amount of total variance explained, and if added up for all 23 axes will equal 1.00.
- **Cumulative proportion** is the cumulative total of the proportion of each axes. While **CA1** explains 0.2534 and **CA2** explains 0.1892 of the variance, their *cumulative* proportion is 0.4426 because it is the total amount of variance they explain together.
- **Species and Site scores** - the relative weight each species and/or site has within each axes.

### Visualising

```{r}
ordi_plot(ca, layers = "sites", geom = "text")%>% 
  gf_lims(x = c(-4, 6), y=c(-3, 9))
ordi_plot(ca, layers = "species", geom = "text")%>% 
  gf_lims(x = c(-2, 4), y=c(-2, 6))
```

## Non-metric Multidimensional Scaling 

NMDS creates the ordination using the rank order of your sites along each axis, rather than absolute multi-dimensional distances. NMDS only makes sure that the points further apart are still further apart in NMDS space than the “closer together” points, so it does not preserve the actual distance. It determines these rankings from pairwise similarity scores between each pair of samples in turn, and analysing the resultant table. The **ordi_nmds()** function by default uses the Bray-Curtis similarity measure which is robust for most data. The algorithm has to run multiple times to find the best solution. If needed, it will automatically standardise your data by either square-root and/or ‘Wisconsin’ standardisation, which standardises species to equal maxima and sites to equal totals. You may see this displayed in the output as the model runs.

The wrapper function **ordi_nmds()** in the package **bio2020** will be used in this practical. A typical PCA in R has this format: **ordi_nmds(data)**

```{r}
dune_nmds <- ordi_nmds(dune)
```

Output explained:

NMDS uses many random starts (20 each time) and looks for the fits with the lowest stress. It will only conclude that a solution has been reached when the solutions with the lowest stress are similar. It also fits the NMDS for 1,2,3...etc dimensions, and stops after a sudden drop in stress is observed. Sometimes the NMDS cannot find a solution on the first try like it has here (you will get back **no convergent solutions**), which is why we've saved the output as the object **dune_nmds**. To run the NMDS on the same data again: 

dune_nmds_2 <- ordi_nmds(dune, previous.best = dune_nmds)

The **previous.best** argument passes in a previous fit of NMDS and will run another 20 random starts (making the total number of random starts 40). However, you do not need to run this on the dune dataset as we have already found a convergent solution. 

Check the output of the nmds:
```{r}
# Check the output
print(dune_nmds)
```

Output explained:

- **Call** - This is a reminder of how you fitted the NMDS.
- **Data** - This is the type of data used, species in this case.
- **Distance** - the dissimilarity metric, in this case the default is *Bray-Curtis*.
- **Dimensions** - the number of dimensions with the least stress. 
- **Two convergent solutions found after 20 tries** - the NMDS did 20 random starts and found 2 solutions that were very similar to one another. If you ran the NMDS twice, it would say **...after 40 tries** here.

### Visualising

```{r}
# Plot the NMDS sample (site) and attribute (species) scores
ordi_plot(dune_nmds, layers="sites", geom="text")
ordi_plot(dune_nmds, layers="species", geom="text")
```
